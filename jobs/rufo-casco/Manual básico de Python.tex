\documentclass[12pt]{article}
\usepackage{mlmodern}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage[left=2.5cm, right=2.5cm, top=2cm, bottom=2cm]{geometry}
\usepackage{multicol}
\usepackage{tasks}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{hyperref}

\hypersetup
{
    colorlinks = true,
    linkcolor = black
}

\settasks{label=\Alph*)}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    numbers=left,            % Números de línea (elimínalos si no los quieres)
    numberstyle=\color{black}, % Estilo de los números de línea
    numbersep=-6pt, % Ajusta este valor (puedes probar con 3pt o 2pt)
    showspaces=false,
    showstringspaces=false,
    tabsize=4,
    frame=single, % Agrega un marco alrededor del código
    rulecolor=\color{blue!30}, % Color del borde del recuadro
    backgroundcolor=\color{cyan!8}, % Fondo celeste muy suave
    keywordstyle=\color{blue!70}, % Palabras reservadas en azul intenso
    commentstyle=\color{brown!90}, % Comentarios en verde
    stringstyle=\color{red!70} % Cadenas de texto en rojo
}

\theoremstyle{definition}
\newtheorem{exercise}{Ejercicio}[section]
\newtheorem{example}{Ejemplo}[section]

\renewcommand{\normalsize}{\fontsize{13}{15}\selectfont} %propuesta 1 (13.5, 16)

\setlength{\parskip}{1.7mm}
\setlength{\parindent}{0pt}
\setlength{\headsep}{3.5mm}

\title{Manual introductorio a Python\\v2}
\author{Kenny J. Tinoco}
\date{Febrero de 2025}

\begin{document}
    \maketitle

    \tableofcontents

    \vspace{5mm}
    \hrule

    \section{Programación imperativa}

    \subsection{Variables}
    Una \textbf{variable} en Python es el nombre que se asigna un dato almacenado con los cuales se harán operaciones,
    estos datos pueden ser de distintas naturalezas que denotaremos como \textbf{tipo}, es decir, pueden ser de tipos
    enteros (\textbf{int}), decimales (\textbf{float}), textos (\textbf{str}), valores booleanos (\textbf{bool}), listas (\textbf{list}), etc.

    Para crear una variable escribimos su nombre y luego asignamos su valor por medio del operador de asignación ``$=$''.

    Una cosa importante a tener en cuenta es que el nombre de una variable tiene ciertas restricciones, la primera es
    que el nombre no puede iniciar por un número, la segunda es que no puede ser una palabra reservada del lenguaje y
    la tercera es que no puede tener caracteres especiales excepto el ``\_'', vamos algunos ejemplos.
    \begin{lstlisting}
    string = "Un string"
    anotherStr = 'a'
    integer = 4
    x = -1
    boolean = x > 0  # (es falso)
    isTrue = True
    isFalse = False
    \end{lstlisting}

    Variables válidas.
    \begin{lstlisting}
    a1239892874 = 1
    x10 = 2
    AGE = 67
    my_lastname = "lopez"
    _name = "luis"
    \end{lstlisting}

    Variables inválidas.
    \begin{lstlisting}
    10x = 1
    name-value = "luis"
    first% = 3
    \end{lstlisting}

    Otro aspecto muy importante es escribir nombre de variables que tenga un sentido dentro del código, evitar escribir
    variables de un solo carácter y en su lugar escribir un sustantivo.

    Vamos a entender como \textbf{sentencia} a cualquier operación sobre un valor, por ejemplo el siguiente código tiene dos sentencias.
    \begin{lstlisting}
    mySurname = "Tinoco"
    print(mySurname)
    \end{lstlisting}

    Todo programa en Python está formado por un conjunto de sentencias que se escriben con el fin de obtener un resultado de interés.
    Cada sentencia se escribe en una línea, sin embargo, es posible escribir más de una sentencia en una sola línea de
    código separándolas por punto y coma.
    \begin{lstlisting}
    mySurname = "Tinoco"; print(mySurname)
    \end{lstlisting}
    Se recomienda nunca escribir más de una sentencia en una línea.

    Si necesitamos escribir texto como una manera de señalar algún aspecto del código, podemos usar el símbolo ``$\#$''
    la cual le indica a lenguaje que ignore todo lo que después del símbolo, es decir, un comentario.

    \begin{lstlisting}
    # Este es un comentario y no se ejecuta.

    aString = "Un texto" #Este es otro comentario
    \end{lstlisting}
    Se recomienda NUNCA USAR COMENTARIOS, ya que el código bien escrito no necesita comentarios.

    La \textbf{identación} tiene una gran importancia en Python, debido a que este forma bloques por
    medio de la identación, esto toma relevancia con los temas de funciones, condicionales, sentencias de control y clases.

    \begin{lstlisting}
    mySurname = "Tinoco"
        print(mySurname)
    \end{lstlisting}

    El código anterior falla debido al significado especial de la identación.

    Cuando hacemos un código como el siguiente
    \begin{lstlisting}
    name = "Rufo"
    age = 34
    \end{lstlisting}

    El lenguaje automáticamente detecta los tipos de datos de los valores y fija ese tipo a la variable.
    Si necesitamos convertir un valor de un tipo a otro hacemos uso de las palabras reservadas de Python.
    \begin{lstlisting}
    age = int("20")
    print(age) # Se imprime el entero 20

    fraction = 0.1
    intFraction = int(fraction) # Se obtiene 0
    \end{lstlisting}

    Claramente hay tipos de datos que no puede ser transformados en otro.
    \begin{lstlisting}
    age = int("Valor")
    \end{lstlisting}

    \subsubsection{Listas}
    Las listas son otro tipo de datos en Python, estas permiten agrupar un conjunto de valores o variables bajo un mismo
    nombre, por ejemplo.

    \begin{lstlisting}
    dogs = ["Keiko", "Max"]
    \end{lstlisting}

    Podemos verificar si un elemento pertenece a una lista por medio del operador \textit{in}, por ejemplo.
    \begin{lstlisting}
    contain = ("Firulais" in dogs)  #Retorna False
    \end{lstlisting}

    Podemos crear una lista vacía.
    \begin{lstlisting}
    myList = []
    \end{lstlisting}

    Podemos hacer referencia a elementos de las listas por medio índices, comenzando desde cero.
    \begin{lstlisting}
    print(dogs[0]) #Imprime Keiko
    print(dogs[1]) #Imprime Max
    \end{lstlisting}

    Para editar el valor de un elemento también hacemos uso de su indice.
    \begin{lstlisting}
    dogs[1] = "Koby"
    \end{lstlisting}

    Podemos extraer una lista de otra, por ejemplo.
    \begin{lstlisting}
    dogs = ["Keiko", "Max", "Koby", "Logan", "Canela"]

    myDogs = dogs[0:2]
    print(myDogs) #Imprime  ["Keiko", "Max"]

    print(dogs[1:]) #Imprime ["Koby", "Logan", "Canela"]
    \end{lstlisting}

    Podemos obtener la cantidad de elementos de una lista por medio del método \textit{len()}.
    \begin{lstlisting}
    dogs = ["Keiko", "Max", "Koby", "Logan", "Canela"]
    quantity = len(dogs)
    print(quantity) #Imprime 5
    \end{lstlisting}

    Para agregar un elemento a una lista podemos usar el método \textit{append()}, por ejemplo.
    \begin{lstlisting}
    list = [2, 3, 5, 7]
    list.append(11)
    \end{lstlisting}

    Si deseamos agregar una lista a otra lista podemos usar el método \textit{extend()}.
    \begin{lstlisting}
    list = [2, 3, 5, 7]
    list.extend([11, 13, 17, 23])
    \end{lstlisting}

    O también usar el operado ``$+=$''.
    \begin{lstlisting}
    list = [2, 3, 5, 7]
    list += [11, 13, 17, 23]
    \end{lstlisting}

    Para eliminar un elemento de la lista usamos el método \textit{remove()}.
    \begin{lstlisting}
    list = [2, 3, 5, 7]
    list.remove(5)

    print(list) #Imprime [2, 3, 7]
    \end{lstlisting}


    \newpage

    \subsection{Operadores}

    Los operadores de Python son símbolos que utilizamos para ejecutar operaciones sobre valores y  variables.
    Podemos dividir los operadores en función del tipo de operación que realizan.
    \begin{itemize}
        \item Operador de asignación
        \item Operadores aritméticos
        \item Operadores de comparación
        \item Operadores lógicos
    \end{itemize}

    El operador de asignación se utiliza para asignar un valor a una variable:
    \begin{lstlisting}
    age = 8
    \end{lstlisting}
    O para asignar un valor de variable a otra variable
    \begin{lstlisting}
    age = 8
    anotherVariable = age
    \end{lstlisting}


    Python tiene varios operadores aritméticos como: $+$ (Suma), $-$ (Resta), $*$ (Multiplicacion), $\%$ (Resto), $**$ (Potencia),
    $/$ (División) y $//$ (División entera).
    \begin{lstlisting}
    1 + 1 #2
    2 - 1 #1
    2 * 2 #4
    4 / 2 #2
    4 % 3 #1
    4 ** 2 #16
    4 // 2 #2
    \end{lstlisting}

    Los operadores numéricos generalmente retorna valores decimales (float), sin embargo, en los casos de resto ($\%$) y división entera ($//$)
    se obtiene valores enteros si los argumentos son enteros, en caso contrario se obtiene float.

    Algo interesante sobre el operador $+$ es que permite ``sumar'' cadenas, ejemplo
    \begin{lstlisting}
    string1 = "Py"
    string2 = "thon"
    print(string1 + string2) #Imprime Python
    \end{lstlisting}

    Python define algunos operadores de comparación:
    \begin{itemize}
        \item $==$
        \item $!=$
        \item $>$
        \item $<$
        \item $>=$
        \item $<=$
    \end{itemize}
    Puedes usar esos operadores para obtener un valor booleano (\textbf{True} o \textbf{False}) según el resultado.

    \begin{lstlisting}
    a = 1
    b = 2
    a == b #False
    a != b #True
    a > b #False
    a <= b #True
    \end{lstlisting}

    Python nos proporciona los siguientes operadores booleanos
    \begin{itemize}
        \item not
        \item and
        \item or
    \end{itemize}
    Cuando se trabaja con atributos True o False, estos funcionan como AND, OR y NOT lógicos, y se utilizan a menudo en
    la evaluación de expresiones condicionales if.

    \begin{lstlisting}
    condition1 = True
    condition2 = False

    not condition1 #se obtiene False
    condition1 and condition2 #se obtiene False
    condition1 or condition2 #se obtiene True
    \end{lstlisting}


    \subsection{Números}
    Los números en Python pueden ser de tres tipos: entero (int), flotantes o reales (float) y complejos (complex).

    Los números enteros se representan usando la clase int.
    La cual nos ayuda definir de manera literal de la forma
    \begin{lstlisting}
    age = 8
    \end{lstlisting}

    Para los números flotantes definimos de manera literal de la forma
    \begin{lstlisting}
    fraction = 0.1
    \end{lstlisting}

    Para los complejos usamos la forma
    \begin{lstlisting}
    complexNumber = 2+3j
    \end{lstlisting}

    O usar el nombre reservado complex
    \begin{lstlisting}
    complexNumber = complex(2, 3)
    \end{lstlisting}
    Podemos acceder a los valores reales e imaginarios por medio del operador de acceso\footnote{El operador de accesos toma relevancia en la orientación de objecto.} ``.'' (punto).
    \begin{lstlisting}
    complexNumber.real #2.0
    complexNumber.imag #3.0
    \end{lstlisting}

    La biblioteca estándar de Python ofrece funciones y constantes de utilidad matemática que son más precisas que los operadores normales.
    \begin{itemize}
        \item El paquete \textit{math} proporciona funciones y constantes matemáticas generales
        \item El paquete \textit{cmath} proporciona utilidades para trabajar con números complejos.
        \item El paquete \textit{decimal} proporciona utilidades para trabajar con decimales y números de punto flotante.
        \item El paquete \textit{fractions} proporciona utilidades para trabajar con números racionales
    \end{itemize}

    Por ejemplo, en el paquete \textit{math} ofrece funciones como ``pow'', ``round'', ``abs'', ``factorial'' entre otras muchas.
    \begin{lstlisting}
    value = pow(2, 10) #2^(10) = 1024
    sqrtOfInteger2 = pow(2, 0.5) #1.414213562...


    value2 = round(sqrtOfInteger2) #1
    value3 = round(sqrtOfInteger2, 3) #1.414
    \end{lstlisting}



    \subsection{Sentencias de control}

    Lo interesante de hacer con los booleanos, y con las expresiones que devuelven un booleano en particular, es que
    podemos tomar decisiones y tomar diferentes caminos según su valor True o False.

    A esto se le conoce como bifurcaciones ya que genera dos opciones en cómo puede ejecutar el programa, dando como resultado
    una toma de decisiones.
    En Python lo hacemos usando la declaración \textit{if}:

    \begin{lstlisting}
    condition = True

    if (condition == True):
        # Hacer algo
    \end{lstlisting}

    Cuando la condición se resuelve como True, como en el caso anterior, su bloque se ejecuta.
    Pero ¿qué es un bloque?, un bloque es la parte que tiene una identación (sangría) de un nivel\footnote{De cuatro espacios generalmente.} a la derecha,
    por ejemplo

    \begin{lstlisting}
    condition = True

    if (condition == True):
        print("The condition")
        print("was true")
    \end{lstlisting}

    El bloque puede estar formado por una sola línea, o por varias líneas, y finaliza cuando se vuelve al nivel de identación anterior:

    \begin{lstlisting}
    condition = True

    if (condition == True):
        print("The condition")
        print("was true")

    print("Outside of the if")
    \end{lstlisting}

    En combinación con \textit{if}, puede tener un bloque \textit{else}, que se ejecuta si la prueba de condición de \textit{if} da como resultado False.
    \begin{lstlisting}
    condition = True

    if (condition == True) :
        print("The condition")
        print("was True")
    else:
        print("The condition")
        print("was False")
    \end{lstlisting}

    Y puedes tener diferentes casos vinculados con \textit{elif}, que se ejecutan si la comprobación anterior fue falsa.

    \begin{lstlisting}
    condition = True
    name = "Roger"

    if (condition == True):
        print("The condition")
        print("was True")
    elif (name == "Roger"):
        print("Hello Roger")
    else:
        print("The condition")
        print("was False")
    \end{lstlisting}

    El segundo bloque en este caso se ejecuta si la condición es False y el valor de la variable de nombre es ``Roger''.
    En una declaración \textbf{if}, puede tener solo una comprobación \textit{if} y \textit{else}, pero varias series de comprobaciones \textit{elif}.

    \begin{lstlisting}
    condition = True
    name = "Roger"

    if (condition == True):
        print("The condition")
        print("was True")
    elif (name == "Roger"):
        print("Hello Roger")
    elif (name == "Syd"):
        print("Hello Syd")
    elif (name == "Flavio"):
        print("Hello Flavio")
    else:
        print("The condition")
        print("was False")
    \end{lstlisting}

    \textit{if} y \textit{else} también se pueden usar en formato en línea, lo que nos permite devolver un
    valor u otro en función de una condición.

    \begin{lstlisting}
    a = 2
    result = 2 if (a % 2 != 0) else 10*a
    print(result) # Imprime 20
    \end{lstlisting}


    \subsection{Cíclos}

    Los cíclos o bucles son una parte esencial de la programación.
    Ya que nos permite realizar operaciones sobre un conjunto de valores con número menor de código.
    En Python tenemos dos tipos de cíclos: \textit{while} y \textit{for}.

    \subsubsection{While}
    El cíclo \textit{while} se definen utilizando la palabra clave while y repiten su bloque hasta que la condición se evalúa como False.

    \begin{lstlisting}
    condition = True

    while (condition == True):
        print("The condition is True")
    \end{lstlisting}

    Este es un cíclos infinito, nunca termina porque la condición no cambia.
    Esto producirá un error por desbordamiento de memoria.

    Por lo cual es necesario que el bloque del cíclo tenga un caso donde el la condición cambie.
    Veamos esto, deteniendo el cíclo justo después de la primera iteración:
    \begin{lstlisting}
    condition = True

    while (condition == True):
        print("The condition is True")
        condition = False

    print("After the loop")
    \end{lstlisting}

    En este caso, se ejecuta la primera iteración, ya que la prueba de condición se evalúa como True, y en la segunda
    iteración la prueba de condición se evalúa como False, por lo que el control pasa a la siguiente instrucción,
    después del cíclo.
    Es común tener un contador para detener la iteración después de una cierta cantidad de ciclos:

    \begin{lstlisting}
    count = 0

    while (count < 10):
        print("The condition is True")
        count = count + 1

    print("After the loop")
    \end{lstlisting}

    \subsubsection{For}

    Mediante un cíclo \textit{for} podemos indicarle a Python que ejecute un bloque una cantidad de veces predeterminada,
    por adelantado y sin necesidad de una variable y una condición independientes para comprobar su valor.
    Por ejemplo, podemos iterar los elementos de una lista como una cadena.

    \begin{lstlisting}
    cadena = "Esta es una cadena."

    for item in cadena:
        print(item) #Se imprime cada caracter en la cadena
    \end{lstlisting}

    \subsubsection{Break y Continue}

    Tanto los cíclos while como los for pueden interrumpirse dentro del bloque, utilizando dos palabras clave especiales: \textit{break} y \textit{continue}.
    \begin{itemize}
        \item La sentencia \textit{continue} detiene la iteración actual y le indica a Python que ejecute la siguiente.
        \item La sentencia \textit{break} detiene el cíclo por completo y continúa con la siguiente instrucción después del final del cíclo.
    \end{itemize}

    Por ejemplo, en el siguiente código no se imprime ninguna letra ``a''.
    \begin{lstlisting}
    cadena = "Esta es una cadena."

    for item in cadena:
        if (item == "a"):
            continue

        print(item)
    \end{lstlisting}

    En el siguiente código se imprime sin llegar a la letra ``c''.
    \begin{lstlisting}
    cadena = "Esta es una cadena."

    for item in cadena:
        if (item == "c"):
            break

        print(item)
    \end{lstlisting}


    \subsection{Funciones}

    Una función nos permite crear un conjunto de instrucciones que podemos ejecutar cuando sea necesario.
    Las funciones son esenciales en Python y en muchos otros lenguajes de programación para crear programas
    significativos, ya que nos permiten descomponer un programa en partes manejables, promueven la legibilidad y la
    reutilización del código.
    Aquí hay un ejemplo de función llamada hello que imprime ``Hola'':

    \begin{lstlisting}
    def hello():
        print('Hola')
    \end{lstlisting}

    Esta es la definición de la función.
    Hay un nombre (hello) y un cuerpo, el conjunto de instrucciones, que es la parte que sigue a los dos puntos y está
    con una identación de un nivel a la derecha.
    Para ejecutar esta función, debemos llamarla.
    Esta es la sintaxis para llamar a la función:

    \begin{lstlisting}
    hello()
    \end{lstlisting}

    Podemos ejecutar esta función una vez o varias veces, el nombre de la función, hello, es muy importante.
    Debe ser descriptivo, para que cualquiera que la llame pueda imaginar lo que hace la función.

    Una función puede aceptar uno o más parámetros:

    \begin{lstlisting}
    def hello(name):
        print('Hello ' + name + '!')
    \end{lstlisting}

    En este caso llamamos a la función pasando el argumento

    \begin{lstlisting}
    hello("Roger")
    \end{lstlisting}

    Así es como podemos aceptar múltiples parámetros:

    \begin{lstlisting}
    def hello(name, age):
        print('Hello ' + name + ', you are ' + str(age)
                                                + ' years old!')
    \end{lstlisting}

    En este caso llamamos a la función pasando un conjunto de argumentos:
    \begin{lstlisting}
    hello("Roger", 20)
    \end{lstlisting}

    Una función puede devolver un valor mediante la sentencia \textit{return}.
    Por ejemplo, en este caso, devolvemos el nombre del parámetro:
    \begin{lstlisting}
    def hello(name):
        print('Hello ' + name + '!')
        return name
    \end{lstlisting}
    Cuando la función cumple con la declaración de retorno, la función finaliza.

    Puede devolver varios valores utilizando valores separados por comas:
    \begin{lstlisting}
    def hello(name):
        print('Hello ' + name + '!')
        return name, 'Roger', 8
    \end{lstlisting}

    En este caso, al llamar a hello('Syd'), el valor de retorno (nota: no lo que está impreso en la pantalla,
    sino el valor de retorno) es una tupla que contiene esos 3 valores: ('Syd', 'Roger', 8):

    \begin{lstlisting}
    def hello(name):
        print('Hello ' + name + '!')
        return name, 'Roger', 8

    print(hello('Syd')) #('Syd', 'Roger', 8)
    \end{lstlisting}

    \begin{example}
        Realizar una función que calcule el factorial de un entero ingresado por pantalla.
    \end{example}

    \begin{lstlisting}
    def factorial(value):
        if(value < 0):
            print("Valor invalido.")
            exit()

        if(value == 0):
            return 1;

        result = 1
        while(value != 0):
            result = result * value
            value = value - 1

        return result
    \end{lstlisting}


    \subsection{Ejercicios}

    \begin{exercise}
        Análisis de los valores float y enteros, probar los siguientes valores en un archivo .py con la ayuda del método print.
        \begin{itemize}
            \item Calcular 12 ** 34 y 12.0 ** 34.0 (notar como Python representa los números por medio de notación científica)
            \item Calcular 1 / 12 ** 34 y ver como se representa.
            \item Asignar los números $12.3\times 10^{45}$ y $12.3\times 10^{-45}$ a un variable usando la notación científica de Python (con e)\footnote{No confundir con la constante de Euler, la e indica exponente base 10.}.
            \item Calcular 123 ** 456.
            \item Calcular 123.0 ** 456.0.
            \item Calcular 123.0 ** 456 y 123 ** 456.0.
        \end{itemize}
    \end{exercise}

    \begin{exercise}
        Usando $==$, $<=$ y $>=$ comparar
        \begin{itemize}
            \item 123 con 123.0
            \item 123 con 123 + 1.0e-10
            \item 123 con 123 + 1.0e-20
        \end{itemize}
    \end{exercise}

    \begin{exercise}
        Ver la diferencias entre
        \begin{itemize}
            \item print(123456) y print(123, 456)
            \item print(``Un comentario'') y print(``Un'', ``comentario'')
        \end{itemize}
    \end{exercise}

    \begin{exercise}
        Hacer un programa que calcule la media aritmética de 6 números que se ingresan por pantalla.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que pida dos ángulos de un triángulo por pantalla e imprima si el triángulo es acutángulo, rectángulo y obtuso.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que pida el radio de una circunferencia y calcule e imprima su área y perímetro.
    \end{exercise}

    \begin{exercise}
        Dado un triángulo rectángulo, hacer un programa que pida por pantalla la hipotenusa y la altura relativa a la
        hipotenusa, y calcule el ángulo opuesto a dicha altura.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que pida los lados de un triángulo y calcule el inradio.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que pida dos números enteros y calcule su MCD, por medio del algoritmo de Euclides.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que pida por pantalla un número entero $n$ mayor a cero y menor a 100.
        Que pida $n$ números por pantalla y calcule la media geometríca.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que pida un valor por pantalla, muestre un menú con las opciones de las cuatro funciones
        trigonométricas inversas, pida la precisión, calcule e imprima el resultado.
    \end{exercise}
    
    \begin{exercise}
        Escribir un algoritmo que calcule los números primos de 0 a 100 utilizando el llamado método de la criba de Eratóstenes.
        Este método consiste en definir e inicializar con todos sus elementos a True un vector de 100 elementos binarios e ir
        pasando a False en pasadas sucesivas todos los múltiplos de los números primos (2, 3, 5, 7, $\ldots$) hasta obtener sólo los números primos.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que calcule y muestre los primeros n números de la serie de Fibonacci.
    \end{exercise}

    \begin{exercise}
        Hacer un programa que pida por pantalla una cantidad (entre 10 y 100) de números enteros y a partir de ellos
        que obtenga las listas ordenadas ascendentemente de los
        \begin{itemize}
            \item números impares,
            \item números pares,
            \item números primos y
            \item números múltiplos de 7,
        \end{itemize}
        junto con la cantidad de elementos de cada lista.
        Luego, que indique cuál lista tiene más elementos.
    \end{exercise}


    \newpage
    \section{Programación orientada a objetos}
    -- Pendiente --

\end{document}